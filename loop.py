import requests
import json
from rich.progress import track
import logging
import click
from collections import defaultdict
from pathlib import Path
from rich.traceback import install
from rich.logging import RichHandler
from rich.table import Table
from rich import print


def generate_summary_table(vuln_table: dict) -> Table:
    """Generate a summary table of the vulnerabilities parsed per keyword.

    Args:
        vuln_table: A key-value mapping of keywords to a list of vulnerabilities.

    Returns:
        A `Rich` table that can be rendered by the `Console` API.
    """
    table = Table(title="Vulnerability summary")
    table.add_column("keyword", style="magenta")
    table.add_column("count")
    for k, v in vuln_table.items():
        table.add_row(k, str(len(v)))
    return table


@click.command()
@click.argument(
    "output_path",
    type=click.Path(writable=True, file_okay=True, dir_okay=False, path_type=Path),
)
def download_data(output_path: Path):
    """Downloads data from the CVE API and saves to disk.

    This will save the vulnerabilities as a key-value mapping from keyword to a
    list of vulnerabilities to OUTPUT_PATH.
    """
    # A map of search keywords to vulnerabilities
    vulnerabilities = defaultdict(list)
    keywords = ["Chromium", "keras", "tensorflow", "FFmpeg"]
    logging.debug(f"Querying vulnerabilities for {len(keywords)} keywords")

    for keyword in track(keywords):
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        start_index = 0
        total = float("inf")

        # According to the API documentation at: https://nvd.nist.gov/developers/vulnerabilities,
        # the responses might be chunked so we might have to request the remaining chunks.
        while start_index < total:
            r = requests.get(url, params={"keywordSearch": keyword})
            if not r.ok:
                logging.error("Failed request for {keyword}")
                continue

            try:
                json_response = r.json()
            except requests.exceptions.JSONDecodeError as e:
                logging.error(
                    f"Failed to parse JSON for {keyword} start index: {start_index}. Error: {e}",
                )
            total = json_response["totalResults"]
            start_index += json_response["resultsPerPage"]
            vulnerabilities[keyword].extend(json_response["vulnerabilities"])

    with open(output_path, "w") as f:
        json.dump(vulnerabilities, f)
    print(f"Wrote JSON file to {output_path}")

    total_vulns = sum([len(v) for _, v in vulnerabilities.items()])
    logging.debug(f"Received {total_vulns} total vulnerability entries")
    table = generate_summary_table(vulnerabilities)
    print(table)


if __name__ == "__main__":
    FORMAT = "%(message)s"
    logging.basicConfig(
        level="NOTSET", format=FORMAT, datefmt="[%X]", handlers=[RichHandler()]
    )
    install(show_locals=False)
    download_data()  # type: ignore
